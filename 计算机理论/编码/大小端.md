# 计算机中的大端存储和小端存储

一、大小端介绍

"大端"和"小端"表示多字节值的哪一端存储在该值的起始地址处;小端存储在起始地址处,即是小端字节序;大端存储在起始地址处,即是大端字节序。
大端存储模式：数据的低位保存在内存中的高地址中，数据的高位保存在内存中的低地址中；左手存储。
小端存储模式：数据的低位保存在内存中的低地址中，数据的高位保存在内存中的高地址中； 右手存储。
在这里插入图片描述
二、为什么会有大小端存储模式

1、cpu和编译器的不同

    在计算机系统中我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit，但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题，因此就导致了大端存储模式和小端存储模式。
    例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。
    我们常用的X86结构是小端模式，而KEIL C51则为大端模式，很多的ARM，DSP都为小端模式，有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。

2、 网络字节序

    网络上传输的数据都是字节流,对于一个多字节数值,在进行网络传输的时候,先传递哪个字节，也就是说,当接收端收到第一个字节的时候,它将这个字节作为高位字节还是低位字节处理,是一个比较有意义的问题。
    UDP/TCP/IP协议规定:把接收到的第一个字节当作高位字节看待,这就要求发送端发送的第一个字节是高位字节;而在发送端发送数据时,发送的第一个字节是该数值在内存中的起始地址处对应的那个字节,也就是说,该数值在内存中的起始地址处对应的那个字节就是要发送的第一个高位字节(即:高位字节存放在低地址处);由此可见,多字节数值在发送之前,在内存中因该是以大端法存放的， 所以说,网络字节序是大端字节序。
    比如,我们经过网络发送整型数值0x12345678时,在80X86平台中,它是以小端发存放的,在发送之前需要使用系统提供的字节序转换函数htonl()将其转换成大端法存放的数值，在进行发送。

三、如何判断cpu使大端存储还是小端存储的

方法1：类型降低
把一个占字节数大的变量赋值给一个占字节数小的变量，小的那个会将大的从起始地地址偏移小的大小个长度的数据拿过来。如果是大端，小的数据拿过来就是高位的数据，如果是小端，小的数据拿过来的就是低位的数据。比如说，short big = 0xff00；char litter = big；大端litter = 0xff，小端litter = 00。

int main()
{
    short big = 0xff00;
    char litter = big;
    if (litter == 0xff)
    {
        cout << "大端" << endl;
    }
    else
    {
        cout << "小端" << endl;
    }
    return 0;
}
